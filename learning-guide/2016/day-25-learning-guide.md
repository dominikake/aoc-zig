# Day 25 Learning Guide: Clock Signal

## Problem Breakdown

### Part 1
We're given an Assembunny program (extended from Days 12/23) with a new `out x` instruction that transmits a value. The program computes a value based on the initial value of register `a`, then repeatedly outputs the least significant bit (LSB) of a counter in an infinite loop. The task is to find the smallest positive integer initial value for `a` such that the program produces an infinite alternating sequence: 0, 1, 0, 1, 0, 1, ...

### Part 2
Part 2 is not available - Day 25 is traditionally the final day with only one part.

## TAOCP Concepts Applied

### Volume 1: Section 1.4.2 - Interpretation of Computer Programs
- **Straight-line programs and loops**: The Assembunny interpreter is a simple register machine with jumps for control flow
- **Instruction execution**: Each instruction updates state (registers and instruction pointer) deterministically
- **Program simulation**: We simulate the program step-by-step rather than executing it natively

### Volume 2: Section 4.1 - Positional Number Systems
- **Binary representation**: Repeated `out` instructions of the LSB emit binary digits in order
- **Radix conversion**: The pattern `0, 1, 0, 1, ...` corresponds to a number with alternating bits
- **Bit extraction**: The program effectively does `while (a != 0) { out a % 2; a /= 2; }`

### Volume 4A: Combinatorial Algorithms
- **Pattern generation**: The infinite output is generated by looping over a fixed sequence of operations
- **Early termination**: We stop simulation as soon as the pattern breaks, avoiding unnecessary computation
- **Search strategy**: Brute force search with early rejection is optimal for this problem

## Programming Concepts

### Interpreter Design
- **Register-based virtual machine**: 4 general-purpose registers (a, b, c, d) storing 64-bit integers
- **Instruction set architecture**: Five operations (cpy, inc, dec, jnz, out) forming a complete instruction set
- **Operand resolution**: Distinguish between immediate values and register references (Value union type)

### Simulation Techniques
- **State machine**: The program state (registers + instruction pointer) evolves deterministically
- **Output buffering**: Collect outputs to verify pattern matching without infinite execution
- **Early termination**: Stop simulation immediately when output deviates from expected pattern

### Pattern Matching and Search
- **Alternating sequence detection**: Track expected next value (0 or 1) and flip after each match
- **Exhaustive search**: Try initial values from 1 upward until correct pattern found
- **Pattern verification**: Check 100+ outputs to ensure infinite pattern (typical loop period is small)

### Algorithmic Analysis
- **Program decompilation**: The input program has structure: compute value, then output bits repeatedly
- **Mathematical insight**: Program computes `final_value = initial_a + 170 * 15 = initial_a + 2550`
- **Binary pattern**: For answer 180, `180 + 2550 = 2730 = 0b101010101010`, which produces alternating outputs

## Zig-Specific Concepts

### Union Types and Enums
- **Tagged unions**: `Value` union with `reg` and `imm` variants for type-safe operand handling
- **Enum opcodes**: `Opcode` enum (cpy, inc, dec, jnz, out) for instruction classification
- **Switch exhaustiveness**: Zig ensures all opcode cases are handled in the interpreter

### Memory Management
- **GeneralPurposeAllocator**: Used for dynamic arrays (instructions, output collection)
- **Arena-like cleanup**: Resources freed in deterministic order (defer statements)
- **Capacity pre-allocation**: `initCapacity(allocator, 50)` avoids reallocations

### Error Handling
- **Error unions**: Functions return `!T` for errors, handled with `try` and `catch`
- **Custom error types**: Define domain-specific errors (InvalidOpcode, MissingOperand, etc.)
- **Early returns**: Use `return error` to exit execution on invalid state

### String and Number Parsing
- **Tokenization**: `std.mem.tokenizeScalar(u8, input, ' ')` for splitting instruction lines
- **Integer parsing**: `std.fmt.parseInt(i64, str, 10)` for converting number strings
- **String formatting**: `std.fmt.allocPrint(allocator, "{d}", .{value})` for output

### Data Structures
- **ArrayList**: Dynamic array for instruction list and output collection
- **Arrays**: Fixed-size `[4]i64` for register storage (compile-time known size)
- **Structs**: `State` and `Instruction` for grouping related data

## Learning Exercises

### Beginner
1. Implement a simple interpreter for a different toy assembly language
2. Write a function that converts a number to binary and outputs bits LSB-first
3. Create a pattern detector that checks if a sequence alternates between two values
4. Practice using Zig unions for representing different data types

### Intermediate
5. Analyze the Assembunny program to understand what it computes before the output loop
6. Implement early termination in a simulation that stops when a condition is met
7. Create a brute force search that tries values until a predicate is satisfied
8. Add debug logging to the interpreter to trace program execution

### Advanced
9. Reverse-engineer the Assembunny program to find a closed-form mathematical solution
10. Implement an optimizer that simplifies the program before simulation
11. Add support for the `tgl` instruction from Day 23 to your interpreter
12. Create a visualizer that shows the program state over time

## Key Insights

### Why Brute Force Works
- The answer is typically small (around 180-3000 for most inputs)
- Simulation is fast: each test takes microseconds
- Early termination rejects wrong `a` values within first 20-30 outputs
- Total search time: < 1 second in Zig

### Mathematical Perspective
- Program computes `d = a + 170 Ã— 15`, then outputs bits of `d` repeatedly
- We need `d` to have alternating binary pattern: `...01010101`
- Smallest positive `a` where `a + 2550` has this pattern
- For answer 180: `180 + 2550 = 2730 = 0b101010101010`

### Code Organization
- **Separate parsing from execution**: `parseInstruction()` creates `Instruction` structs
- **Interpreter as pure function**: `execute()` takes State and returns new State
- **Pattern checking integrated**: Early termination during simulation, not post-processing
- **Testability**: Each component tested independently (parsing, execution, pattern matching)

### Performance Considerations
- **Pre-allocated buffers**: Avoid heap allocations during hot loop
- **Register indexing**: Direct array access `regs[idx]` is faster than maps
- **Minimal state copying**: Pass State by pointer to avoid copying
- **Early rejection**: Don't collect all outputs if pattern breaks early

### Common Pitfalls
- **Infinite loops**: Always add iteration limits to prevent hanging on bad inputs
- **Off-by-one errors**: Ensure instruction pointer updates correctly for jumps
- **Type confusion**: Distinguish between immediate values and register references
- **Pattern off-by-one**: First output should be 0, then 1, then 0, ...

## Cross-References

- **Day 12**: First introduction to Assembunny interpreter (cpy, inc, dec, jnz, tgl)
- **Day 23**: Extended Assembunny with tgl instruction
- **Day 20**: Circular arithmetic and pattern matching (similar alternating pattern concept)
- **Day 18**: Cellular automaton simulation (similar state machine concept)

## Additional Resources

- TAOCP Vol 1, Section 1.4.2: Straight-line programs and loops
- TAOCP Vol 2, Section 4.1: Positional number systems and radix conversion
- Zig Documentation: Unions, Enums, Error Handling, ArrayList
